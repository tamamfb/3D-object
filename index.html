<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lab PC – Warna & Bentuk Fix (Back OK)</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; font-family:Arial, Helvetica, sans-serif; background:#f0f0f0; }
    #info { position:absolute; top:10px; left:10px; color:#222; background:rgba(255,255,255,0.92); padding:8px 10px; border-radius:8px; font-size:14px; z-index:100; }
    canvas { display:block; cursor:grab; }
    canvas:active { cursor:grabbing; }
  </style>
</head>
<body>
  <div id="info">Drag untuk rotasi • Scroll untuk zoom • Panah ← → ↑ ↓ geser PC</div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    /* ===== PARAM ===== */
    const RENDER_SCALE = 1;
    const fov = 75 * Math.PI / 180;
    const near = 0.05;

    // Palet disesuaikan foto
    const COLORS = {
      deskTop:   '#e2c69a',   // kayu muda
      deskEdge:  '#d9b277',
      legs:      '#2b2b2b',   // panel kaki
      backPanel: '#8b6a3e',   // <- COKLAT (bukan hitam)

      bezel:     '#e6e6e6',
      backCase:  '#cfd3d8',
      screenOff: '#0d0d0d',
      stand:     '#6d747a'
    };

    // Kamera
    let rotation = { x: -0.22, y: 0.35 };
    let targetRotation = { ...rotation };
    let zoom = 46;
    let cosX=1, sinX=0, cosY=1, sinY=0, projectionScale=1;

    // Posisi PC
    let pcPos = { x: 0, z: -1 };
    const deskWidth = 35, deskDepth = 25, pcBaseRadius = 4;
    const maxX = (deskWidth / 2) - pcBaseRadius - 1;
    const maxZ = (deskDepth / 2) - pcBaseRadius - 1;

    /* ===== FRAMEBUFFERS ===== */
    let fbWidth=0, fbHeight=0, depthBuffer=null, imgData=null, data=null;
    const off = document.createElement('canvas');
    const octx = off.getContext('2d', { willReadFrequently:true });

    function resizeCanvas() {
      canvas.width = Math.floor(window.innerWidth);
      canvas.height = Math.floor(window.innerHeight);
      fbWidth  = Math.max(1, Math.floor(canvas.width  * RENDER_SCALE));
      fbHeight = Math.max(1, Math.floor(canvas.height * RENDER_SCALE));
      depthBuffer = new Float32Array(fbWidth * fbHeight);
      imgData = new ImageData(fbWidth, fbHeight);
      data = imgData.data;
      off.width = fbWidth; off.height = fbHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function clearBuffers() {
      const bg = 0xf0f0f0, r=(bg>>16)&255, g=(bg>>8)&255, b=bg&255;
      for (let i=0;i<data.length;i+=4){ data[i]=r; data[i+1]=g; data[i+2]=b; data[i+3]=255; }
      depthBuffer.fill(Infinity);
    }

    /* ===== MATH / PIPELINE ===== */
    function transformPoint(x,y,z){
      const rx = x * cosY - z * sinY;
      let   rz = x * sinY + z * cosY;
      const ry = y * cosX - rz * sinX;
      rz = y * sinX + rz * cosX;
      return { x: rx, y: ry, z: rz + zoom };
    }
    function projectVS(t){
      const s = projectionScale / t.z;
      return { x: (fbWidth/2) + t.x*s, y: (fbHeight/2) - t.y*s, z: t.z };
    }
    function clipNear(viewVerts){
      const out=[]; const n=viewVerts.length;
      for(let i=0;i<n;i++){
        const a=viewVerts[i], b=viewVerts[(i+1)%n];
        const aIn=a.z>near, bIn=b.z>near;
        if(aIn && bIn) out.push(b);
        else if(aIn && !bIn){
          const t=(near-a.z)/(b.z-a.z);
          out.push({x:a.x+(b.x-a.x)*t,y:a.y+(b.y-a.y)*t,z:near});
        } else if(!aIn && bIn){
          const t=(near-a.z)/(b.z-a.z);
          out.push({x:a.x+(b.x-a.x)*t,y:a.y+(b.y-a.y)*t,z:near});
          out.push(b);
        }
      }
      return out;
    }
    function normalView(v){
      const a=v[0], b=v[1], c=v[2];
      const ux=b.x-a.x, uy=b.y-a.y, uz=b.z-a.z;
      const vx=c.x-a.x, vy=c.y-a.y, vz=c.z-a.z;
      return { x: uy*vz-uz*vy, y: uz*vx-ux*vz, z: ux*vy-uy*vx };
    }
    function normalize(n){ const l=Math.hypot(n.x,n.y,n.z)||1; return {x:n.x/l,y:n.y/l,z:n.z/l}; }
    const LIGHT_DIR = normalize({x:-0.35,y:0.8,z:-0.45});
    function lambert(viewVerts, base=1){
      const n=normalize(normalView(viewVerts));
      return Math.max(0.25, base * (0.55 + 0.45 * Math.max(0, n.x*LIGHT_DIR.x+n.y*LIGHT_DIR.y+n.z*LIGHT_DIR.z)));
    }
    const colorCache = new Map();
    function colorRGB(hex, lit){
      const key = hex + '|' + lit.toFixed(3);
      let c = colorCache.get(key);
      if (c) return c;
      const r0=parseInt(hex.slice(1,3),16), g0=parseInt(hex.slice(3,5),16), b0=parseInt(hex.slice(5,7),16);
      c = { r:(r0*lit)|0, g:(g0*lit)|0, b:(b0*lit)|0 };
      colorCache.set(key,c);
      return c;
    }
    function rasterTri(p0,p1,p2,col,zbias){
      const x0=p0.x,y0=p0.y,z0=p0.z, x1=p1.x,y1=p1.y,z1=p1.z, x2=p2.x,y2=p2.y,z2=p2.z;
      const invZ0=1/z0, invZ1=1/z1, invZ2=1/z2;
      const minX=Math.max(0,Math.floor(Math.min(x0,x1,x2)));
      const minY=Math.max(0,Math.floor(Math.min(y0,y1,y2)));
      const maxX=Math.min(fbWidth-1, Math.ceil(Math.max(x0,x1,x2)));
      const maxY=Math.min(fbHeight-1,Math.ceil(Math.max(y0,y1,y2)));
      const area=(x1-x0)*(y2-y0)-(y1-y0)*(x2-x0); if (Math.abs(area)<1e-6) return;
      const invA=1/area;
      for(let y=minY;y<=maxY;y++){
        const cy=y+0.5;
        for(let x=minX;x<=maxX;x++){
          const cx=x+0.5;
          const w0=(x1-x0)*(cy-y0)-(y1-y0)*(cx-x0);
          const w1=(x2-x1)*(cy-y1)-(y2-y1)*(cx-x1);
          const w2=(x0-x2)*(cy-y2)-(y0-y2)*(cx-x2);
          if((w0>=0&&w1>=0&&w2>=0)||(w0<=0&&w1<=0&&w2<=0)){
            const b0=w1*invA, b1=w2*invA, b2=1-b0-b1;
            const invZ=b0*invZ0+b1*invZ1+b2*invZ2;
            const z=1/invZ + zbias;
            const idx=y*fbWidth+x;
            if(z < depthBuffer[idx]){
              depthBuffer[idx]=z;
              const di=idx*4; data[di]=col.r; data[di+1]=col.g; data[di+2]=col.b; data[di+3]=255;
            }
          }
        }
      }
    }
    function drawPolyWorld(vertsWorld, hex, baseLight=1, zbias=0){
      let view=vertsWorld.map(v=>transformPoint(v[0],v[1],v[2]));
      view=clipNear(view); if(view.length<3) return;
      const n=normalView(view); const dot=n.x*view[0].x+n.y*view[0].y+n.z*view[0].z; if (dot>=0) return;
      const lit=lambert(view, baseLight);
      const col=colorRGB(hex, lit);
      const p=view.map(projectVS);
      for(let i=1;i<p.length-1;i++) rasterTri(p[0],p[i],p[i+1],col,zbias);
    }

    /* ===== PRIMITIVES ===== */
    function addBox(cx,cy,cz,sx,sy,sz,color,faceBias=null,faceLight=null){
      const hx=sx/2, hy=sy/2, hz=sz/2;
      const v=[
        [cx-hx,cy-hy,cz-hz],[cx+hx,cy-hy,cz-hz],[cx+hx,cy+hy,cz-hz],[cx-hx,cy+hy,cz-hz],
        [cx-hx,cy-hy,cz+hz],[cx+hx,cy-hy,cz+hz],[cx+hx,cy+hy,cz+hz],[cx-hx,cy+hy,cz+hz]
      ];
      const faces=[ [[0,1,2,3],0.65], [[4,7,6,5],1.0], [[0,4,5,1],0.55], [[2,6,7,3],0.92], [[0,3,7,4],0.75], [[1,5,6,2],0.80] ];
      for (let i=0;i<faces.length;i++){
        const [idx,L0]=faces[i];
        const poly=idx.map(j=>v[j]);
        const bias = faceBias ? (faceBias[i]||0) : 0;
        const L = faceLight ? (faceLight[i]||L0) : L0;
        drawPolyWorld(poly, color, L, bias);
      }
    }
    function addFrustum(cx,cy,cz, sx,sy,sz, tx=0.1,ty=0.1, color='#ffffff', bias=null, light=null){
      const hx=sx/2, hy=sy/2, hz=sz/2;
      const sx2=sx*(1-tx), sy2=sy*(1-ty), hx2=sx2/2, hy2=sy2/2;
      const front=[[cx-hx,cy-hy,cz-hz],[cx+hx,cy-hy,cz-hz],[cx+hx,cy+hy,cz-hz],[cx-hx,cy+hy,cz-hz]];
      const back=[[cx-hx2,cy-hy2,cz+hz],[cx+hx2,cy-hy2,cz+hz],[cx+hx2,cy+hy2,cz+hz],[cx-hx2,cy+hy2,cz+hz]];
      const faces=[
        [[front[0],front[1],front[2],front[3]],0.95],
        [[back[0],back[3],back[2],back[1]],0.72],
        [[front[0],back[0],back[1],front[1]],0.82],
        [[front[3],front[2],back[2],back[3]],0.92],
        [[front[0],front[3],back[3],back[0]],0.80],
        [[front[1],back[1],back[2],front[2]],0.82]
      ];
      for(let i=0;i<faces.length;i++){
        const face=faces[i][0], L0=faces[i][1];
        const b=bias?(bias[i]||0):0, L=light?(light[i]||L0):L0;
        drawPolyWorld(face, color, L, b);
      }
    }
    function addRacetrackBase(cx, cy, cz, length, radius, height, color){
      const bodyLen = Math.max(0.001, length - 2*radius);
      addBox(cx, cy, cz, bodyLen, height, radius*2, color);
      const seg=28, aStep=(Math.PI*2)/seg, h=height/2;
      function addDisc(centerX){
        const top=[], bottom=[];
        for(let i=0;i<seg;i++){
          const a=i*aStep; const x=centerX + Math.cos(a)*radius; const z=cz + Math.sin(a)*radius;
          top.push([x, cy+h, z]); bottom.push([x, cy-h, z]);
        }
        const topC=[centerX, cy+h, cz], botC=[centerX, cy-h, cz];
        for(let i=0;i<seg;i++){ const n=(i+1)%seg;
          drawPolyWorld([topC, top[i], top[n]], color, 0.9, -0.0002);
          drawPolyWorld([botC, bottom[n], bottom[i]], color, 0.6, -0.0002);
          drawPolyWorld([bottom[i], bottom[n], top[n], top[i]], color, 0.85, -0.0002);
        }
      }
      addDisc(cx - bodyLen/2); addDisc(cx + bodyLen/2);
    }

    /* ===== SCENE ===== */
    function drawTable(){
      addBox(0, -0.6, 0, deskWidth, 1.2, deskDepth, COLORS.deskTop, [0,0,0,-0.0006,0,0]);
      addBox(0, -0.2, deskDepth/2, deskWidth, 0.8, 1, COLORS.deskEdge, [0,0,0,+0.0004,0,0]);
      addBox(-deskWidth/2, -8.6, 0, 1, 16, deskDepth, COLORS.legs);
      addBox( deskWidth/2, -8.6, 0, 1, 16, deskDepth, COLORS.legs);
      // PANEL BELAKANG COKLAT
      addBox(0, -4.6, -deskDepth/2, deskWidth, 8, 1, COLORS.backPanel);
    }

    function drawPC(){
      // Dimensi monitor
      const OUT_W = 24.0, OUT_H = 13.5, FRAME_D = 1.2;
      const SCREEN_W = 23.0, SCREEN_H = 12.9, SCREEN_D = 0.35;
      const FRAME_Z = pcPos.z - FRAME_D/2;

      // Base & leher
      addRacetrackBase(pcPos.x, 0.0, pcPos.z - 0.6, 8.5, 2.1, 0.35, COLORS.stand);
      addFrustum(pcPos.x, 3.2, pcPos.z - 0.9, 1.2, 6.0, 0.8, 0.12, 0.08, COLORS.stand);

      // Bezel depan
      addBox(pcPos.x, 8.0, FRAME_Z, OUT_W, OUT_H, FRAME_D, COLORS.bezel);

      // *** HOUSING BELAKANG BARU (flat & rapi) ***
      const REAR_D = 1.6;                 // kedalaman belakang
      const rearFrontZ = FRAME_Z - FRAME_D/2;   // menempel ke belakang bezel
      const rearCenterZ = rearFrontZ - REAR_D/2;
      // frustum sangat subtle (hampir flat), tidak cekung
      addFrustum(pcPos.x, 8.0, rearCenterZ, OUT_W*0.94, OUT_H*0.96, REAR_D, 0.06, 0.06, COLORS.backCase);

      // Screen (inset tipis, bias supaya menang di dalam frame)
      const screenBias=[-0.0006,-0.0006,0,0,0,0];
      addBox(pcPos.x, 8.0, FRAME_Z + 0.45, SCREEN_W, SCREEN_H, SCREEN_D, COLORS.screenOff, screenBias);
    }

    function drawScene(){
      drawTable();
      drawPC();
    }

    /* ===== RENDER LOOP ===== */
    function render(){
      rotation.x += (targetRotation.x - rotation.x) * 0.12;
      rotation.y += (targetRotation.y - rotation.y) * 0.12;
      cosX = Math.cos(rotation.x); sinX = Math.sin(rotation.x);
      cosY = Math.cos(rotation.y); sinY = Math.sin(rotation.y);
      projectionScale = (fbWidth/2) / Math.tan(fov/2);

      clearBuffers();
      drawScene();

      octx.putImageData(imgData, 0, 0);
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(off, 0, 0, canvas.width, canvas.height);
      requestAnimationFrame(render);
    }

    /* ===== CONTROLS ===== */
    let dragging=false, lastX=0,lastY=0;
    canvas.addEventListener('mousedown', e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; });
    canvas.addEventListener('mousemove', e=>{
      if(!dragging) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      targetRotation.y += dx*0.01;
      targetRotation.x += dy*0.01;
      targetRotation.x = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, targetRotation.x));
      lastX=e.clientX; lastY=e.clientY;
    });
    ['mouseup','mouseleave'].forEach(ev=>canvas.addEventListener(ev,()=>dragging=false));
    canvas.addEventListener('wheel', e=>{
      zoom += e.deltaY*0.05;
      zoom = Math.max(15, Math.min(80, zoom));
      e.preventDefault();
    }, { passive:false });

    document.addEventListener('keydown', e=>{
      const step = 0.8;
      switch(e.key){
        case 'ArrowLeft':  pcPos.x = Math.max(-maxX, pcPos.x - step); break;
        case 'ArrowRight': pcPos.x = Math.min( maxX, pcPos.x + step); break;
        case 'ArrowUp':    pcPos.z = Math.max(-maxZ, pcPos.z - step); break;
        case 'ArrowDown':  pcPos.z = Math.min( maxZ, pcPos.z + step); break;
        default: return;
      }
      e.preventDefault();
    });

    render();
  </script>
</body>
</html>
