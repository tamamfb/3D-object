<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D PC + Meja (tanpa mouse)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;font-family:Arial,Helvetica,sans-serif}
    #info{position:absolute;top:10px;left:10px;color:#222;background:rgba(255,255,255,.92);padding:8px 10px;border-radius:8px;font-size:14px}
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ===== Scene =====
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 30);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // ===== Lighting =====
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);

    const dir = new THREE.DirectionalLight(0xffffff, 0.85);
    dir.position.set(10, 20, 10);
    dir.castShadow = true;
    dir.shadow.camera.near = 0.1;
    dir.shadow.camera.far = 50;
    dir.shadow.camera.left = -20;
    dir.shadow.camera.right = 20;
    dir.shadow.camera.top = 20;
    dir.shadow.camera.bottom = -20;
    scene.add(dir);

    // ===== Materials =====
    const monitorMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 30 }); // White frame
    const screenMaterial  = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 10 });
    const standMaterial   = new THREE.MeshPhongMaterial({ color: 0x7f8c8d, shininess: 60 });
    const darkDetailMat   = new THREE.MeshPhongMaterial({ color: 0x2f343a, shininess: 20 });

    // ===== Monitor =====
    const monitorGroup = new THREE.Group();

    // Screen
    const screenGeom = new THREE.BoxGeometry(20, 12, 0.5);
    const screen = new THREE.Mesh(screenGeom, screenMaterial);
    screen.position.y = 8; screen.castShadow = true; screen.receiveShadow = true;
    monitorGroup.add(screen);

    // Frame
    const frameGeom = new THREE.BoxGeometry(22, 14, 1);
    const frame = new THREE.Mesh(frameGeom, monitorMaterial);
    frame.position.set(0, 8, -0.5);
    frame.castShadow = true; frame.receiveShadow = true;
    monitorGroup.add(frame);

    // Neck
    const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 6, 20), standMaterial);
    neck.position.set(0, 2, -1); neck.castShadow = true; monitorGroup.add(neck);

    // Base
    const base = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 0.5, 48), standMaterial);
    base.position.set(0, -0.5, -1); base.castShadow = true; monitorGroup.add(base);

    // Posisi monitor - nempel di atas meja
    const deskTopY = 0; // permukaan atas meja
    const baseHeight = 0.5;
    monitorGroup.position.y = deskTopY + baseHeight; // base monitor tepat di atas permukaan meja
    scene.add(monitorGroup);

    // ===== Desk/Table =====
    const deskMaterial = new THREE.MeshPhongMaterial({ color: 0xd4a574, shininess: 15 }); // light brown
    const deskEdgeMaterial = new THREE.MeshPhongMaterial({ color: 0xc19660, shininess: 20 }); // slightly darker edge
    const blackPanelMaterial = new THREE.MeshPhongMaterial({ color: 0x2c2c2c, shininess: 10 }); // black panels
    const deskGroup = new THREE.Group();

    // Desktop surface
    const desktopThickness = 1.2;
    const desktop = new THREE.Mesh(new THREE.BoxGeometry(35, desktopThickness, 25), deskMaterial);
    const desktopY = -0.6; // posisi pusat ketebalan desktop
    desktop.position.y = desktopY;
    desktop.castShadow = true;
    desktop.receiveShadow = true;
    deskGroup.add(desktop);

    // Front edge (aksen)
    const frontEdge = new THREE.Mesh(new THREE.BoxGeometry(35, 0.8, 1), deskEdgeMaterial);
    frontEdge.position.set(0, desktopY + 0.4, 12.5);
    frontEdge.castShadow = true;
    deskGroup.add(frontEdge);

    // Panel samping kiri (hitam, full tinggi)
    const undersideY = desktopY - desktopThickness / 2;
    const panelHeight = 16;
    const panelY = undersideY - panelHeight / 2;
    
    const leftPanel = new THREE.Mesh(
      new THREE.BoxGeometry(1, panelHeight, 25), 
      blackPanelMaterial
    );
    leftPanel.position.set(-17.5, panelY, 0);
    leftPanel.castShadow = true;
    deskGroup.add(leftPanel);

    // Panel samping kanan (hitam, full tinggi)
    const rightPanel = new THREE.Mesh(
      new THREE.BoxGeometry(1, panelHeight, 25), 
      blackPanelMaterial
    );
    rightPanel.position.set(17.5, panelY, 0);
    rightPanel.castShadow = true;
    deskGroup.add(rightPanel);

    // Panel belakang (coklat, setengah tinggi)
    const backPanelHeight = panelHeight / 2;
    const backPanelY = undersideY - backPanelHeight / 2;
    
    const backPanel = new THREE.Mesh(
      new THREE.BoxGeometry(35, backPanelHeight, 1), 
      deskEdgeMaterial
    );
    backPanel.position.set(0, backPanelY, -12.5);
    backPanel.castShadow = true;
    deskGroup.add(backPanel);

    scene.add(deskGroup);

    // ===== Ground (untuk shadow) =====
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100),
      new THREE.ShadowMaterial({ opacity: 0.28 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -1;
    ground.receiveShadow = true;
    scene.add(ground);

    // ===== Drag/Zoom controls (tanpa OrbitControls) =====
    let mouseX = 0, mouseY = 0, targetRotX = 0, targetRotY = 0, dragging = false;

    renderer.domElement.addEventListener('mousedown', () => dragging = true);
    renderer.domElement.addEventListener('mouseup',   () => dragging = false);
    renderer.domElement.addEventListener('mouseleave',() => dragging = false);
    renderer.domElement.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      mouseX = (e.clientX / window.innerWidth) * 2 - 1;
      mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
      targetRotY = mouseX * Math.PI;
      targetRotX = mouseY * Math.PI / 4;
    });

    // Touch
    renderer.domElement.addEventListener('touchstart', () => { dragging = true; });
    renderer.domElement.addEventListener('touchend',   () => dragging = false);
    renderer.domElement.addEventListener('touchmove',  (ev) => {
      if (!dragging) return;
      const t = ev.touches[0];
      mouseX = (t.clientX / window.innerWidth) * 2 - 1;
      mouseY = -(t.clientY / window.innerHeight) * 2 + 1;
      targetRotY = mouseX * Math.PI;
      targetRotX = mouseY * Math.PI / 4;
    });

    // Zoom
    renderer.domElement.addEventListener('wheel', (ev) => {
      camera.position.z += ev.deltaY * 0.05;
      camera.position.z = Math.max(15, Math.min(50, camera.position.z));
    });

    // ===== Animate =====
    let rotX = 0, rotY = 0;
    function animate(){
      requestAnimationFrame(animate);
      rotY += (targetRotY - rotY) * 0.06;
      rotX += (targetRotX - rotX) * 0.06;
      scene.rotation.y = rotY;
      scene.rotation.x = rotX * 0.3;
      renderer.render(scene, camera);
    }

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>